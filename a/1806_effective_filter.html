<p><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="bc.css">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js" type="text/javascript"></script>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head></p>
<!---

twitter:

 in the #RevitAPI #DynamoBim @AutodeskForge @AutodeskRevit #bim #ForgeDevCon http://bit.ly/combiningedges

&ndash; 
...

linkedin:


#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk

the [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread

<p style="font-size: 80%; font-style:italic"></p>

-->

<h3>Effective Filtered Element Collector</h3>
<h4><a name="2"></a> Effective Filtered Element Collector</h4>
<p>Efficient way to check if an element exists in a view</p>
<p><strong>Question:</strong> I'm creating a list of views that contain .dwg ImportInstance(s).
For each view in the document, I'm using a <code>FilteredElementCollector</code> to get a list of elements meeting the criteria; if this list is not empty, the view is added to the list:</p>
<pre class="code">
  foreach (Element e in viewElements)
  {
    View view = (View) e;

    var stopwatch = new Stopwatch();
    stopwatch.Start();

    List<Element> elementsInView
      = new FilteredElementCollector(doc, view.Id)
        .OfClass(typeof(ImportInstance))
        .Where(e => e.Category.Name.EndsWith(".dwg"))
        .OfType<Element>()
        .ToList();

    stopwatch.Stop();

    Debug.WriteLine(view.Name + ": "
      + stopwatch.ElapsedMilliseconds + "ms");

    // if the current view contains at least 1 DWG
    // ImportInstance, add the view to the list

    if(elementsInView.Count > 0) 
    {
      viewsWithCAD.Add(view);
      continue;
    }
  }
</pre>

<p>The FilteredElementCollector can understandably take more than 4000 ms to collect elements from a view containing many elements.</p>
<p>My goal is only to see if a single element exists in a view &ndash; not to collect all of the elements meeting the criteria; if I could make the FilteredElementCollector stop immediately after finding an element meeting the criteria, that would be helpful. </p>
<p>I would appreciate any advice on how to achieve this more efficiently.</p>
<p>Thank you.</p>
<p><strong>Answer by Fair59</strong>, <a href="https://forums.autodesk.com/t5/user/viewprofilepage/user-id/2083518">Frank Aarssen</a>:
Stopping the collector at the first element:</p>
<pre class="code">
  Element e1
    = new FilteredElementCollector(doc, view.Id)
      .OfClass(typeof(ImportInstance))
      .FirstElement();
</pre>

<p>Possible Speed improvement:</p>
<ul>
<li>Select all ImportInstances</li>
<li>If it is not a DWG: exclude from collector in view-loop &rarr; no need for <code>category.Name</code> check in loop</li>
<li>Else: if DWG is ViewSpecific, i.e., is "2D annotation" in view &rarr; owner view contains DWG, can be added to <code>viewsWithCAD</code>, and can be excluded from view-loop</li>
</ul>
<pre class="code">
  IEnumerable<ImportInstance> instances
    = new FilteredElementCollector(doc)
      .OfClass(typeof(ImportInstance))
      .Cast<ImportInstance>();

  List<ElementId> toExclude = new List<ElementId>();
  foreach(ImportInstance instance in instances)
  {
    if ( !instance.Category.Name.EndsWith(".dwg"))
    {
      toExclude.Add(instance.Id);
      continue;
    }
    if( instance.ViewSpecific) // dwg only exists in ownerview
    {
      View ownerview = doc.GetElement(instance.OwnerViewId) as View;
      viewsWithCAD.Add(ownerview);
      if( viewElements.Contains(ownerview))
        viewElements.Remove(ownerview);
    }
  }

  foreach (Element e in viewElements)
  {
    View view = (View) e;
    var stopwatch = new Stopwatch();
    stopwatch.Start();
    Element e1 = null;
    if (toExclude.Count>0)
    {
      e1 = new FilteredElementCollector(doc, view.Id)
        .Excluding(toExclude)
        .OfClass(typeof(ImportInstance))
        .FirstElement();
    } else{
      e1 = new FilteredElementCollector(doc, view.Id)
        .OfClass(typeof(ImportInstance))
        .FirstElement();
    }
    stopwatch.Stop();
    Debug.WriteLine(view.Name + ": "
      + stopwatch.ElapsedMilliseconds + "ms");

    // if the current view contains at least 1 DWG
    // ImportInstance, add the view to the list

    if(e1!=null)
    {
      viewsWithCAD.Add(view);
    }
  }
</pre>

<p><strong>Notes:</strong> Many thanks for the interesting question, and many thanks to Fair59 for yet another extremely knowledgeable and helpful solution!</p>
<p>I do keep pointing out that converting a filtered element collector to a List is an inefficient thing to do, if you can avoid it.</p>
<p>It forces the collector to retrieve all the data, convert it to the .NET memory space, duplicate it, costing time and space.</p>
<p>For the same reasons, it is much more efficient to test and apply as many filters as possible within the Revit memory space before passing any data across to .NET.</p>
<p>In this case, you can test the parameter values using a parameter filter instead of the LINQ post-processing that you are applying in you sample code snippet.</p>
<p>As Fair59 points out and we have discussed in the past, you can cancel a collector as soon as your target has been reached:</p>
<ul>
<li><a href="https://thebuildingcoder.typepad.com/blog/2019/02/cancelling-filtered-element-collection.html">Aborting Filtered Element Collection </a></li>
</ul>
<p>So, you can save time and space in several ways:</p>
<p>Use a parameter filter instead of LINQ post-processing</p>
<p>Do not convert to a List</p>
<p>Both of these force the filtered element collector to retrieve and return all results.</p>
<p>Here is an explanation of the various types of filters versus post-processing in .NET:</p>
<ul>
<li><a href="https://thebuildingcoder.typepad.com/blog/2019/04/slow-slower-still-and-faster-filtering.html">Slow, Slower Still and Faster Filtering</a></li>
</ul>
<p>Here are some discussions and a benchmark of the results of using a parameter filter versus LINQ post-processing:</p>
<ul>
<li><a href="https://thebuildingcoder.typepad.com/blog/2018/06/forge-tutorials-and-filtering-for-a-parameter-value.html#3">Filtering for a Specific Parameter Value</a></li>
<li><a href="https://thebuildingcoder.typepad.com/blog/2019/05/filtered-element-collector-benchmark.html#3">Filtered Element Collector Benchmark</a></li>
</ul>
<p>We also discussed the issue of finding all views displaying an element a couple of times in the past:</p>
<ul>
<li><a href="https://thebuildingcoder.typepad.com/blog/2014/05/views-displaying-given-element-svg-and-nosql.html#6">Views Displaying Given Element</a></li>
<li><a href="https://thebuildingcoder.typepad.com/blog/2016/12/determining-views-showing-an-element.html">Determining Views Showing an Element</a></li>
<li><a href="https://thebuildingcoder.typepad.com/blog/2017/05/retrieving-elements-visible-in-view.html">Retrieving Elements Visible in View</a></li>
<li><a href="https://thebuildingcoder.typepad.com/blog/2019/10/generating-graphics-and-collecting-assets.html#2">Can You Avoid Generating Graphics?</a></li>
</ul>
<h4><a name="3"></a></h4>
<h4><a name="4"></a></h4>
<h4><a name="5"></a></h4>
<p><center>
<img src="img/.png" alt="" width="100"> <!--680-->
<p style="font-size: 80%; font-style:italic"></p>
</center></p>
<p><strong>Answer:</strong> Two steps:</p>
<p><strong>Response:</strong> </p>
<pre class="code">
</pre>

<p>Many thanks to  for raising and solving this interesting task.</p>