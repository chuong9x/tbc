<head>
<link rel="stylesheet" type="text/css" href="bc.css">
</head>

<h3>Apollonian Sphere Packing via Web Service and AVF</h3>

<p>Spheres are not as common as planar faceted objects in the architectural domain.
In spite of that, this week has been the week of the spheres, after looking at how to 

<a href="http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html#3">
generate spherical solids</a>,

<a href="http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html#4">
display them using AVF</a>,

and use them for

<a href="http://thebuildingcoder.typepad.com/blog/2012/09/filter-for-touching-beams-using-solid-intersection.html">
geometrical proximity filtering</a>.

<p>We'll round this off now by displaying <b>lots</b> of spheres.
A convenient and interesting way to generate a large number of them is to use Kean Walmsley's 

<a href="http://en.wikipedia.org/wiki/Apollonian_gasket">
Apollonian gasket</a> and

<a href="http://en.wikipedia.org/wiki/Apollonian_sphere_packing">
sphere packing</a>

<a href="http://apollonian.cloudapp.net">
web service</a> to 

fill a sphere with solid spheres 

(<a href="http://thebuildingcoder.typepad.com/blog/2012/06/getting-going-with-the-cloud.html#3">project overview</a>).

<p>To give you a quick first impression of what it is all about, here are some views of different levels of Apollonian sphere packing using Revit transient solids generated by the GeometryCreationUtilities class and its CreateRevolvedGeometry method and displayed in the Revit graphics area using the Analysis Visualization Framework

<a href="http://thebuildingcoder.typepad.com/blog/avf">
AVF</a>.
Apollonian packing with three levels:</p>

<center>
<img src="img/apollonian_2.png" alt="Apollonian packing with three levels" width="300"/>
</center>

<p>Apollonian packing with five levels:</p>

<center>
<img src="img/apollonian_4.png" alt="Apollonian packing with five levels" width="300"/>
</center>

<p>Apollonian packing with seven levels:</p>

<center>
<img src="img/apollonian_6.png" alt="Apollonian packing with seven levels" width="300"/>
</center>

<p>Retrieval and display of this data in Revit requires the following steps and functionality, listed here in the order of their implementation in the source code:

<ul>
<li><a href="#2">String formatting and parsing</a>
<li><a href="#3">Web service request and JSON deserialisation</a>
<li><a href="#4">AVF Functionality</a>
<li><a href="#5">Spherical solid creation and mainline putting it all together</a>
</ul>

<p>I'll simply present these sections of code with some comments on each.



<a name="2"></a>

<h4>String Formatting and Parsing</h4>

<p>The string formatting and parsing is required both to obtain input data from the user and to present some timing and statistical results at the end.

<p>The input to the sphere packing algorithm web service consists of an outer sphere radius and the number of steps to execute, which varies from 2 upwards, where 10 is a pretty high number.

<p>I implemented a little .NET form to request this input from the user together with a centre point defining the location in the Revit model to display the packing:

<center>
<img src="img/apollonian_input.png" alt="Apollonian sphere packing input data"/>
</center>

<p>The following trivial methods are used to parse this input data and format the timing results:</p>

<pre class="code">
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;summary&gt;</span>
&nbsp; <span class="gray">///</span><span class="green"> Return a string for a real number</span>
&nbsp; <span class="gray">///</span><span class="green"> formatted to two decimal places.</span>
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;/summary&gt;</span>
&nbsp; <span class="blue">public</span> <span class="blue">static</span> <span class="blue">string</span> RealString( <span class="blue">double</span> a )
&nbsp; {
&nbsp; &nbsp; <span class="blue">return</span> a.ToString( <span class="maroon">&quot;0.##&quot;</span> );
&nbsp; }
&nbsp;
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;summary&gt;</span>
&nbsp; <span class="gray">///</span><span class="green"> Return an integer parsed </span>
&nbsp; <span class="gray">///</span><span class="green"> from the given string.</span>
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;/summary&gt;</span>
&nbsp; <span class="blue">static</span> <span class="blue">int</span> StringToInt( <span class="blue">string</span> s )
&nbsp; {
&nbsp; &nbsp; <span class="blue">return</span> <span class="blue">int</span>.Parse( s );
&nbsp; }
&nbsp;
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;summary&gt;</span>
&nbsp; <span class="gray">///</span><span class="green"> Return a real number parsed </span>
&nbsp; <span class="gray">///</span><span class="green"> from the given string.</span>
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;/summary&gt;</span>
&nbsp; <span class="blue">static</span> <span class="blue">double</span> StringToReal( <span class="blue">string</span> s )
&nbsp; {
&nbsp; &nbsp; <span class="blue">return</span> <span class="blue">double</span>.Parse( s );
&nbsp; }
&nbsp;
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;summary&gt;</span>
&nbsp; <span class="gray">///</span><span class="green"> Return an XYZ point or vector </span>
&nbsp; <span class="gray">///</span><span class="green"> parsed from the given string.</span>
&nbsp; <span class="gray">///</span><span class="green"> </span><span class="gray">&lt;/summary&gt;</span>
&nbsp; <span class="blue">static</span> <span class="teal">XYZ</span> StringToPoint( <span class="blue">string</span> s )
&nbsp; {
&nbsp; &nbsp; s.TrimStart( <span class="blue">new</span> <span class="blue">char</span>[] { <span class="maroon">'('</span>, <span class="maroon">' '</span> } );
&nbsp; &nbsp; s.TrimEnd( <span class="blue">new</span> <span class="blue">char</span>[] { <span class="maroon">')'</span>, <span class="maroon">' '</span> } );
&nbsp; &nbsp; <span class="blue">string</span>[] a = s.Split( <span class="blue">new</span> <span class="blue">char</span>[] { <span class="maroon">','</span>, <span class="maroon">' '</span> } );
&nbsp; &nbsp; <span class="blue">return</span> ( 3 == a.Length ) 
&nbsp; &nbsp; &nbsp; ? <span class="blue">new</span> <span class="teal">XYZ</span>( 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringToReal( a[0] ), 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringToReal( a[1] ), 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringToReal( a[2] ) )
&nbsp; &nbsp; &nbsp; : <span class="blue">null</span>;
&nbsp; }
</pre>

<p>All trivial stuff, and still it helps to have it nicely sorted.



<a name="3"></a>

<h4>Web service request and JSON deserialisation</h4>

<p>The use of Kean's sphere packing web service is straightforward.

<p>You send it an HTTP request, it returns results in JSON format, you unpack them, and Bob's your uncle.

<p>Kean describes it in detail and presents the source code implementing it in his discussion of 

<a href="http://through-the-interface.typepad.com/through_the_interface/2012/04/consuming-data-from-a-restful-web-service-inside-autocad-using-net.html">
consuming data from a restful web service</a>.

<p>It was originally designed for use in AutoCAD.NET.
I simply grabbed his code and reuse it completely unchanged:

<pre class="code">
&nbsp; <span class="blue">static</span> <span class="blue">dynamic</span> ApollonianPackingWs( 
&nbsp; &nbsp; <span class="blue">double</span> r, 
&nbsp; &nbsp; <span class="blue">int</span> numSteps, 
&nbsp; &nbsp; <span class="blue">bool</span> circles )
&nbsp; {
&nbsp; &nbsp; <span class="blue">string</span> json = <span class="blue">null</span>;
&nbsp;
&nbsp; &nbsp; <span class="green">// Call our web-service synchronously (this </span>
&nbsp; &nbsp; <span class="green">// isn't ideal, as it blocks the UI thread)</span>
&nbsp;
&nbsp; &nbsp; <span class="teal">HttpWebRequest</span> request =
&nbsp; &nbsp; &nbsp; <span class="teal">WebRequest</span>.Create(
&nbsp; &nbsp; &nbsp; &nbsp; <span class="green">//&quot;http://localhost:64114/api/&quot;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="maroon">&quot;http://apollonian.cloudapp.net/api/&quot;</span>
&nbsp; &nbsp; &nbsp; &nbsp; + ( circles ? <span class="maroon">&quot;circles&quot;</span> : <span class="maroon">&quot;spheres&quot;</span> )
&nbsp; &nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;/&quot;</span> + r.ToString()
&nbsp; &nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;/&quot;</span> + numSteps.ToString()
&nbsp; &nbsp; &nbsp; ) <span class="blue">as</span> <span class="teal">HttpWebRequest</span>;
&nbsp;
&nbsp; &nbsp; <span class="green">// Get the response</span>
&nbsp;
&nbsp; &nbsp; <span class="blue">using</span>(
&nbsp; &nbsp; &nbsp; <span class="teal">HttpWebResponse</span> response =
&nbsp; &nbsp; &nbsp; &nbsp; request.GetResponse() <span class="blue">as</span> <span class="teal">HttpWebResponse</span>
&nbsp; &nbsp; &nbsp; )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="green">// Get the response stream</span>
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">StreamReader</span> reader =
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">new</span> <span class="teal">StreamReader</span>( 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.GetResponseStream() );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="green">// Extract our JSON results</span>
&nbsp;
&nbsp; &nbsp; &nbsp; json = reader.ReadToEnd();
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( !<span class="teal">String</span>.IsNullOrEmpty( json ) )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="green">// Use our dynamic JSON converter to </span>
&nbsp; &nbsp; &nbsp; <span class="green">// populate/return our list of results</span>
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">var</span> serializer = <span class="blue">new</span> <span class="teal">JavaScriptSerializer</span>();
&nbsp; &nbsp; &nbsp; serializer.RegisterConverters(
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">new</span>[] { <span class="blue">new</span> <span class="teal">DynamicJsonConverter</span>() }
&nbsp; &nbsp; &nbsp; );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="green">// We need to make sure we have enough space </span>
&nbsp; &nbsp; &nbsp; <span class="green">// for our JSON, as the default limit may well </span>
&nbsp; &nbsp; &nbsp; <span class="green">// get exceeded</span>
&nbsp;
&nbsp; &nbsp; &nbsp; serializer.MaxJsonLength = 50000000;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">return</span> serializer.Deserialize( json, 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">typeof</span>( <span class="teal">List</span>&lt;<span class="blue">object</span>&gt; ) );
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="blue">return</span> <span class="blue">null</span>;
&nbsp; }
</pre>


<a name="4"></a>

<h4>AVF Functionality</h4>

<p>The code implementing AVF functionality has also already been presented and discussed elsewhere.
The last use I made of it was for the initial

<a href="http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html">
sphere display using AVF</a>.

<p>All I did here was to replace the PaintSolid method used there to handle multiple solids.
I implemented this trivial helper class to associate a solid with a level in order to represent the levels in different colours in the visualisation:

<pre class="code">
&nbsp; <span class="blue">class</span> <span class="teal">SolidAndLevel</span>
&nbsp; {
&nbsp; &nbsp; <span class="blue">public</span> <span class="teal">Solid</span> Solid { <span class="blue">get</span>; <span class="blue">set</span>; }
&nbsp; &nbsp; <span class="blue">public</span> <span class="blue">int</span> Level { <span class="blue">get</span>; <span class="blue">set</span>; }
&nbsp; }
</pre>

<p>Here is the code to create an AVF display style, get or create a SpatialFieldManager, set up an analysis result schema, and display the spherical solids using PaintSolids, taking a list of SolidAndLevel instances as input:

<pre class="code">
&nbsp; <span class="blue">void</span> CreateAvfDisplayStyle(
&nbsp; &nbsp; <span class="teal">Document</span> doc,
&nbsp; &nbsp; <span class="teal">View</span> view )
&nbsp; {
&nbsp; &nbsp; <span class="blue">using</span>( <span class="teal">Transaction</span> t = <span class="blue">new</span> <span class="teal">Transaction</span>( doc ) )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; t.Start( <span class="maroon">&quot;Create AVF Style&quot;</span> );
&nbsp; &nbsp; &nbsp; <span class="teal">AnalysisDisplayColoredSurfaceSettings</span>
&nbsp; &nbsp; &nbsp; &nbsp; coloredSurfaceSettings = <span class="blue">new</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">AnalysisDisplayColoredSurfaceSettings</span>();
&nbsp;
&nbsp; &nbsp; &nbsp; coloredSurfaceSettings.ShowGridLines = <span class="blue">false</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">AnalysisDisplayColorSettings</span> colorSettings
&nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">AnalysisDisplayColorSettings</span>();
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">AnalysisDisplayLegendSettings</span> legendSettings
&nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">AnalysisDisplayLegendSettings</span>();
&nbsp;
&nbsp; &nbsp; &nbsp; legendSettings.ShowLegend = <span class="blue">false</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">AnalysisDisplayStyle</span> analysisDisplayStyle
&nbsp; &nbsp; &nbsp; &nbsp; = <span class="teal">AnalysisDisplayStyle</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .CreateAnalysisDisplayStyle( doc,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="maroon">&quot;Paint Solid&quot;</span>, coloredSurfaceSettings,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colorSettings, legendSettings );
&nbsp;
&nbsp; &nbsp; &nbsp; view.AnalysisDisplayStyleId
&nbsp; &nbsp; &nbsp; &nbsp; = analysisDisplayStyle.Id;
&nbsp;
&nbsp; &nbsp; &nbsp; t.Commit();
&nbsp; &nbsp; }
&nbsp; }
&nbsp;
&nbsp; <span class="blue">static</span> <span class="blue">int</span> _schemaId = -1;
&nbsp;
&nbsp; <span class="blue">void</span> PaintSolids(
&nbsp; &nbsp; <span class="teal">Document</span> doc,
&nbsp; &nbsp; <span class="teal">IList</span>&lt;<span class="teal">SolidAndLevel</span>&gt; solids )
&nbsp; {
&nbsp; &nbsp; <span class="teal">Application</span> app = doc.Application;
&nbsp;
&nbsp; &nbsp; <span class="teal">View</span> view = doc.ActiveView;
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( view.AnalysisDisplayStyleId
&nbsp; &nbsp; &nbsp; == <span class="teal">ElementId</span>.InvalidElementId )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; CreateAvfDisplayStyle( doc, view );
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="teal">SpatialFieldManager</span> sfm
&nbsp; &nbsp; &nbsp; = <span class="teal">SpatialFieldManager</span>.GetSpatialFieldManager(
&nbsp; &nbsp; &nbsp; &nbsp; view );
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( <span class="blue">null</span> == sfm )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; sfm = <span class="teal">SpatialFieldManager</span>
&nbsp; &nbsp; &nbsp; &nbsp; .CreateSpatialFieldManager( view, 1 );
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( _schemaId != -1 )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="teal">IList</span>&lt;<span class="blue">int</span>&gt; results
&nbsp; &nbsp; &nbsp; &nbsp; = sfm.GetRegisteredResults();
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">if</span>( !results.Contains( _schemaId ) )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; _schemaId = -1;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( _schemaId == -1 )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="teal">AnalysisResultSchema</span> resultSchema
&nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">AnalysisResultSchema</span>(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="maroon">&quot;PaintedSolids&quot;</span>, <span class="maroon">&quot;Description&quot;</span> );
&nbsp;
&nbsp; &nbsp; &nbsp; _schemaId = sfm.RegisterResult( resultSchema );
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="blue">foreach</span>( <span class="teal">SolidAndLevel</span> sl <span class="blue">in</span> solids )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="teal">FaceArray</span> faces = sl.Solid.Faces;
&nbsp; &nbsp; &nbsp; <span class="teal">Transform</span> trf = <span class="teal">Transform</span>.Identity;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">foreach</span>( <span class="teal">Face</span> face <span class="blue">in</span> faces )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">int</span> idx = sfm.AddSpatialFieldPrimitive(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; face, trf );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">IList</span>&lt;<span class="teal">UV</span>&gt; uvPts = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="teal">UV</span>&gt;( 1 );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; uvPts.Add( face.GetBoundingBox().Min );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">FieldDomainPointsByUV</span> pnts
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">FieldDomainPointsByUV</span>( uvPts );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">List</span>&lt;<span class="blue">double</span>&gt; doubleList 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="blue">double</span>&gt;( 1 );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; doubleList.Add( sl.Level );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">IList</span>&lt;<span class="teal">ValueAtPoint</span>&gt; valList
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="teal">ValueAtPoint</span>&gt;( 1 );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; valList.Add( <span class="blue">new</span> <span class="teal">ValueAtPoint</span>( doubleList ) );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="teal">FieldValues</span> vals = <span class="blue">new</span> <span class="teal">FieldValues</span>( valList );
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; sfm.UpdateSpatialFieldPrimitive(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx, pnts, vals, _schemaId );
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; }
</pre>


<a name="5"></a>

<h4>Spherical Solid Creation and Mainline</h4>

<p>The spherical solid creation is absolutely unchanged from the 

<a href="http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html#3">
discussion on Monday</a>,

so I can get right down to the mainline Execute method putting it all together.
It

<ul>
<li>Checks that we are in a 3D view.
<li>Prompts the user for the input data.
<li>Calls the web service and extracts the results.
<li>Creates the spherical solids.
<li>Paints the solids.
</ul>

<p>Each of the steps is timed, the spheres are counted, and the final results are presented, looking like this for three levels:</p>

<center>
<img src="img/apollonian_2_msg.png" alt="Results of Apollonian packing with three levels"/>
</center>

<p>For five levels:</p>

<center>
<img src="img/apollonian_4_msg.png" alt="Results of Apollonian packing with five levels"/>
</center>

<p>For seven levels:</p>

<center>
<img src="img/apollonian_6_msg.png" alt="Results of Apollonian packing with seven levels"/>
</center>

<p>Revit actually required some additional time on my system to complete and return from the command after these messages were displayed, and mostly that took longer than the entire command execution itself.

<p>Here is the Execute mainline implementing these steps:

<pre class="code">
&nbsp; <span class="blue">public</span> <span class="teal">Result</span> Execute(
&nbsp; &nbsp; <span class="teal">ExternalCommandData</span> commandData,
&nbsp; &nbsp; <span class="blue">ref</span> <span class="blue">string</span> message,
&nbsp; &nbsp; <span class="teal">ElementSet</span> elements )
&nbsp; {
&nbsp; &nbsp; <span class="teal">UIApplication</span> uiapp = commandData.Application;
&nbsp; &nbsp; <span class="teal">UIDocument</span> uidoc = uiapp.ActiveUIDocument;
&nbsp; &nbsp; <span class="teal">Application</span> app = uiapp.Application;
&nbsp; &nbsp; <span class="teal">CreationApp</span> creapp = app.Create;
&nbsp; &nbsp; <span class="teal">Document</span> doc = uidoc.Document;
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( !(doc.ActiveView <span class="blue">is</span> <span class="teal">View3D</span>) )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; message 
&nbsp; &nbsp; &nbsp; &nbsp; = <span class="maroon">&quot;Please run this commahnd in a 3D view.&quot;</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">return</span> <span class="teal">Result</span>.Failed;
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="teal">XYZ</span> centre = <span class="teal">XYZ</span>.Zero;
&nbsp; &nbsp; <span class="blue">double</span> radius = 100.0;
&nbsp; &nbsp; <span class="blue">int</span> steps = 3;
&nbsp;
&nbsp; &nbsp; <span class="blue">using</span>( <span class="teal">Form1</span> f = <span class="blue">new</span> <span class="teal">Form1</span>() )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="blue">if</span>( <span class="teal">DialogResult</span>.OK != f.ShowDialog() )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">return</span> <span class="teal">Result</span>.Cancelled;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; centre = StringToPoint( f.GetCentre() );
&nbsp; &nbsp; &nbsp; radius = StringToReal( f.GetRadius() );
&nbsp; &nbsp; &nbsp; steps = StringToInt( f.GetLevel() );
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="green">// Time the web service operation</span>
&nbsp;
&nbsp; &nbsp; <span class="teal">Stopwatch</span> sw = <span class="teal">Stopwatch</span>.StartNew();
&nbsp;
&nbsp; &nbsp; <span class="blue">dynamic</span> res = ApollonianPackingWs( 
&nbsp; &nbsp; &nbsp; radius, steps, <span class="blue">false</span> );
&nbsp;
&nbsp; &nbsp; sw.Stop();
&nbsp;
&nbsp; &nbsp; <span class="blue">double</span> timeWs = sw.Elapsed.TotalSeconds;
&nbsp;
&nbsp; &nbsp; <span class="green">// Create solids, going through our &quot;dynamic&quot;</span>
&nbsp; &nbsp; <span class="green">// list, accessing each property dynamically</span>
&nbsp;
&nbsp; &nbsp; sw = <span class="teal">Stopwatch</span>.StartNew();
&nbsp;
&nbsp; &nbsp; <span class="teal">List</span>&lt;<span class="teal">SolidAndLevel</span>&gt; solids 
&nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="teal">SolidAndLevel</span>&gt;();
&nbsp;
&nbsp; &nbsp; <span class="teal">Dictionary</span>&lt;<span class="blue">int</span>, <span class="blue">int</span>&gt; counters 
&nbsp; &nbsp; &nbsp; = <span class="blue">new</span> <span class="teal">Dictionary</span>&lt;<span class="blue">int</span>, <span class="blue">int</span>&gt;();
&nbsp;
&nbsp; &nbsp; <span class="blue">foreach</span>( <span class="blue">dynamic</span> tup <span class="blue">in</span> res )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="blue">double</span> rad = System.<span class="teal">Math</span>.Abs( (<span class="blue">double</span>) tup.R );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Debug</span>.Assert( 0 &lt; rad, 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="maroon">&quot;expected positive sphere radius&quot;</span> );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">XYZ</span> cen = <span class="blue">new</span> <span class="teal">XYZ</span>( (<span class="blue">double</span>) tup.X, 
&nbsp; &nbsp; &nbsp; &nbsp; (<span class="blue">double</span>) tup.Y, (<span class="blue">double</span>) tup.Z );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">int</span> lev = tup.L;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Solid</span> s = CreateSphereAt( creapp, cen, rad );
&nbsp;
&nbsp; &nbsp; &nbsp; solids.Add( <span class="blue">new</span> <span class="teal">SolidAndLevel</span> { 
&nbsp; &nbsp; &nbsp; &nbsp; Solid = s, Level = lev } );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">if</span>( !counters.ContainsKey( lev ) )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; counters[lev] = 0;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; ++counters[lev];
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; sw.Stop();
&nbsp;
&nbsp; &nbsp; <span class="blue">double</span> timeSpheres = sw.Elapsed.TotalSeconds;
&nbsp;
&nbsp; &nbsp; <span class="green">// Set up AVF and paint solids</span>
&nbsp;
&nbsp; &nbsp; sw = <span class="teal">Stopwatch</span>.StartNew();
&nbsp;
&nbsp; &nbsp; PaintSolids( doc, solids );
&nbsp;
&nbsp; &nbsp; sw.Stop();
&nbsp;
&nbsp; &nbsp; <span class="blue">double</span> timeAvf = sw.Elapsed.TotalSeconds;
&nbsp;
&nbsp; &nbsp; <span class="blue">int</span> total = 0;
&nbsp; &nbsp; <span class="blue">string</span> counts = <span class="blue">string</span>.Empty;
&nbsp; &nbsp; <span class="teal">List</span>&lt;<span class="blue">int</span>&gt; keys = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="blue">int</span>&gt;( counters.Keys );
&nbsp; &nbsp; keys.Sort();
&nbsp; &nbsp; <span class="blue">foreach</span>( <span class="blue">int</span> key <span class="blue">in</span> keys )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="blue">if</span>( 0 &lt; counts.Length )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; counts += <span class="maroon">&quot;,&quot;</span>;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; <span class="blue">int</span> n = counters[key];
&nbsp; &nbsp; &nbsp; counts += n.ToString();
&nbsp; &nbsp; &nbsp; total += n;
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; <span class="blue">string</span> report = <span class="blue">string</span>.Format( 
&nbsp; &nbsp; &nbsp; <span class="maroon">&quot;{0} levels retrieved with following sphere &quot;</span>
&nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;counts: {1} = total {2}; times in seconds &quot;</span>
&nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;for web service {3}, sphere creation {4} &quot;</span>
&nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;and AVF {5}.&quot;</span>,
&nbsp; &nbsp; &nbsp; counters.Count, counts, total, 
&nbsp; &nbsp; &nbsp; RealString( timeWs ), 
&nbsp; &nbsp; &nbsp; RealString( timeSpheres ), 
&nbsp; &nbsp; &nbsp; RealString( timeAvf ) );
&nbsp;
&nbsp; &nbsp; <span class="teal">TaskDialog</span>.Show( <span class="maroon">&quot;Apollonian Packing&quot;</span>, report );
&nbsp;
&nbsp; &nbsp; <span class="blue">return</span> <span class="teal">Result</span>.Succeeded;
&nbsp; }
</pre>

<p>Since Kean did all the web service implementation and JSON extraction work for me, it all boiled down to just putting together a few ready-made components.
Thank you, Kean!

<p>Please refer to Kean's 

<a href="http://through-the-interface.typepad.com/through_the_interface/2012/06/cloud-mobile-series-summary.html">
project overview</a> for 

all the nitty-gritty background details.

<p>Here is 

<a href="zip/Apollonian.zip">Apollonian.zip</a> containing

the complete source code, Visual Studio solution and add-in manifest for this external command.

<p>Anyway, this should provide enough spheres for this week and keep us all happy and occupied over the weekend.
