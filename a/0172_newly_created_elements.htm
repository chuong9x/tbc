<style>
.blue { color: blue; }
.teal { color: teal; }
.maroon { color: maroon; }
.green { color: green; }
.gray { color: gray; }
</style>

<!-- 

  1251576 [How to mirror a Family Instance element]
  1251677 [Mirroring Family Instances like Structural Columns and Structural Framing]

-->

<h3>Retrieving Newly Created Elements</h3>

<p>The day before yesterday, I demonstrated the use of the 

<a href="http://thebuildingcoder.typepad.com/blog/2009/07/mirror-an-element.html">
Mirror method</a>.

Henrik Bengtsson of 

<a href="http://www.lindab.se">
Lindab</a>

immediately came back with a question on this.

Funnily enough, the reason I quickly posted the article the day before yesterday was because someone completely different asked the exact same two questions as Henrik in the exact same sequence.
There seems to be some kind of 

<a href="http://en.wikipedia.org/wiki/Morphic_field#Morphogenetic_field">
morphogenetic resonance</a>

going on among Revit developers.
Anyway, here is Henrik's question:</p>
<p><strong>Question:</strong>
The mirror command works all right according to the description.
I now face another issue that I had not thought of before. 
How can I get a reference to the newly created mirrored objects?
Those are actually the objects that I want to continue working with.</p>

<p><strong>Answer:</strong>
Because this question was already asked once this morning, I had some time to meditate deeply on how to retrieve the newly created elements generated by the mirroring operation. 
My first idea was to grab them by parsing the tail of the journal file, but unfortunately they are not listed there. 
My second idea works, however:</p>

<ul>
<li>Ask the document for all its elements before the mirroring operation and remember the total number <i><strong>n</strong></i>.
<li>Call the Mirror method, generating a number of new elements.
<li>Ask the document for all its elements again, and retrieve the ones whose index exceeds <i><strong>n</strong></i>.
</ul>

<p>I make use of two helper methods for this:</p>

<ul>
<li>GetElementCount determines the total number of document elements before the mirroring operation.</li>
<li>GetElementsAfter returns a list of all document elements whose index exceeds a given number.</li>
</ul>

<p>Here is the implementation of these two methods:</p>

<pre class="code">
<span class="blue">int</span> GetElementCount( <span class="teal">Document</span> doc )
{
&nbsp; <span class="blue">int</span> count = 0;
&nbsp; <span class="teal">ElementIterator</span> it = doc.Elements;
&nbsp; <span class="blue">while</span>( it.MoveNext() ) 
&nbsp; { 
&nbsp; &nbsp; ++count; 
&nbsp; }
&nbsp; <span class="blue">return</span> count;
}
&nbsp;
<span class="teal">List</span>&lt;<span class="teal">Element</span>&gt; GetElementsAfter( <span class="blue">int</span> n, <span class="teal">Document</span> doc )
{
&nbsp; <span class="teal">List</span>&lt;<span class="teal">Element</span>&gt; a = <span class="blue">new</span> <span class="teal">List</span>&lt;<span class="teal">Element</span>&gt;( n );
&nbsp; <span class="teal">ElementIterator</span> it = doc.Elements;
&nbsp; <span class="blue">int</span> i = 0;
&nbsp;
&nbsp; <span class="blue">while</span>( it.MoveNext() ) 
&nbsp; {
&nbsp; &nbsp; ++i;
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( n &lt; i )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; a.Add( it.Current <span class="blue">as</span> <span class="teal">Element</span> );
&nbsp; &nbsp; }
&nbsp; }
&nbsp; <span class="blue">return</span> a;
}
</pre>

<p>Here is the code for the new external command implementing this.
It is a simple extension of the 

<a href="http://thebuildingcoder.typepad.com/blog/2009/07/mirror-an-element.html">
mirroring command CmdMirror</a>

presented on Wednesday:</p>

<pre class="code">
<span class="teal">Application</span> app = commandData.Application;
<span class="teal">Document</span> doc = app.ActiveDocument;
&nbsp;
<span class="teal">ElementSet</span> els = doc.Selection.Elements;
&nbsp;
<span class="teal">Line</span> line = app.Create.NewLine( 
&nbsp; <span class="teal">XYZ</span>.Zero, <span class="teal">XYZ</span>.BasisX, <span class="blue">true</span> );
&nbsp;
<span class="blue">int</span> n = GetElementCount( doc );
&nbsp;
doc.Mirror( els, line );
&nbsp;
<span class="teal">List</span>&lt;<span class="teal">Element</span>&gt; a = GetElementsAfter( n, doc );
&nbsp;
<span class="blue">string</span> s = <span class="maroon">&quot;The following elements were mirrored:\r\n&quot;</span>;
&nbsp;
<span class="blue">foreach</span>( <span class="teal">Element</span> e <span class="blue">in</span> a )
{
&nbsp; s += <span class="blue">string</span>.Format( <span class="maroon">&quot;\r\n&nbsp; {0}&quot;</span>,
&nbsp; &nbsp; <span class="teal">Util</span>.ElementDescription( e ) );
}
<span class="teal">Util</span>.InfoMsg( s );
&nbsp;
<span class="blue">return</span> <span class="teal">CmdResult</span>.Succeeded;
</pre>

<p>Here is

<a href="zip/bc11041.zip">
version 1.1.0.41</a>

of the complete Visual Studio solution including the mirroring command CmdMirror and the new command CmdMirrorListAdded.</p>

<p><strong>Disclaimer:</strong>
Please note that there is nothing in the Revit API documentation stating that the iterator returned by doc.Elements will traverse the elements in the order they were added to the database.
That happens to be the case today and has been so in the past.
This behaviour may change without notice in the future.
Since the GetElementCount and GetElementsAfter methods depend on this behaviour, they will stop working if it changes.
</p>

