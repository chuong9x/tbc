<p><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="bc.css">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js" type="text/javascript"></script>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head></p>
<!---

twitter:

- post the news about Design Automation webinars
  https://forge.autodesk.com/blog/design-automation-api-webinar-series-register-now
  /a/doc/revit/tbc/git/a/img/da_for_air3.png

- Nice sample showing two stacked ribbon items versus 3:
  24x24 StackedItems
  https://forums.autodesk.com/t5/revit-api-forum/24x24-stackeditems/m-p/9168470

- Very important hint from Fair59 on reinitialising the filtered element collector
  https://forums.autodesk.com/t5/revit-api-forum/collection-of-elements-created-using-elementworksetfilter-giving/m-p/9164018
  This misunderstanding caused a similar problem in another recent case...

 the #RevitAPI #DynamoBim @AutodeskForge @AutodeskRevit #bim #ForgeDevCon 

&ndash; 
...

linkedin:


#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk

the [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread

<p style="font-size: 80%; font-style:italic"></p>

-->

<h3>Design Automation Webinars</h3>
<p>If you are looking for the ultimatively painless introduction to the Forge Design Automation API, you are in luck: the Design Automation webinars are coming up soon.</p>
<p>If you are more interested in the desktop Revit API, the solution for creating two stacked ribbon items instead of three might be more to your tase.</p>
<p>In either case, the tip on reinitialising a filtered element collector before reusing it is importantissimo in both contexts:</p>
<ul>
<li><a href="#2">Forge Design Automation API webinars</a></li>
<li><a href="#3">Stacking two 24x24 ribbon items</a></li>
<li><a href="#4">Reinitialising the filtered element collector</a></li>
</ul>
<p><center>
<img src="img/da_for_air3.png" alt="Forge Design Automation API for AutoCAD, Inventor, Revit and 3DS Max" width="400"> <!--800-->
</center></p>
<pre class="code">
</pre>

<h4><a name="2"></a> Forge Desing Automation API Webinars</h4>
<p>A new series of webinars on
the <a href="https://forge.autodesk.com/en/docs/design-automation/v3/developers_guide/overview/">Forge Design Automation APIs for AutoCAD, Inventor, Revit and 3DS Max</a> is
coming up.</p>
<p>You can register now to participate and also to gain access to the recordings that will be posted after the live events.</p>
<p>There is still time to get hands on with the new Design Automation APIs.
Four webinars are scheduled in December that will cover each of the Design Automation APIs in depth.
The recordings will be posted after so be sure to register to take advantage.</p>
<p>All webinars begin at 8:00 AM Pacific Standard Time.</p>
<ul>
<li>AutoCAD &ndash; December 5
<br/>Design Automation API for AutoCAD on Forge
<br/><strong>Albert Szilvasy</strong>, software Architect will share details about the new and updated API.
<br/>This webinar discusses how the Design Automation for AutoCAD empowers customers and partners to get more work done more quickly, reliably and collaboratively using cloud-based web services.
We will demonstrate the ability to run scripts on your design files, leveraging the scale of the Forge Platform to automate repetitive tasks.
<br/><a href="https://autodesk.zoom.us/webinar/register/WN_n-yZWaSNSW-OIMJRDdJBZw">Register</a></li>
<li>Revit &ndash; December 10
<br/>Design Automation API for REVIT on Forge
<br/><strong>Sasha Crotty</strong>, Senior Product Manager, Revit Platform &amp; Services to share updates on this API.
<br/>This webinar discusses how the Design Automation for Revit empowers customers and partners to get more work done more quickly, reliably and collaboratively using cloud-based web services.
We will demonstrate how you can automate your most common, manual, and error-prone work to improve responsiveness and free up your time so you can focus on more valuable work.
<br/><a href="https://autodesk.zoom.us/webinar/register/WN_50PU3thnSfC8m-Rh2PE2Ag">Register</a></li>
<li>Inventor &ndash; December 11
<br/>Design Automation API for Inventor on Forge
<br/><strong>Andrew Akenson</strong>, software Architect will shares details about the new and updated APIs added to the Design Automation for Inventor on Forge.
<br/>This webinar discusses how the Design Automation for Inventor empowers customers and partners to get more work done more quickly, reliably and collaboratively using cloud-based web services.
We will demonstrate how you can automate your most common, manual, and error-prone work to improve responsiveness and free up your time so you can focus on more valuable work.
<br/><a href="https://autodesk.zoom.us/webinar/register/WN_8poFofy4QWCfq0ciL0AYjg">Register</a></li>
<li>3DS Max &ndash; December 12
<br/>Design Automation API for 3ds Max on Forge
<br/><strong>Kevin Vandecar</strong>, Developer Advocate on the Forge Partner Development team will share details about the newly launched Design Automation API for 3ds Max on Forge.
<br/>In this webinar, we will discuss how the Design Automation for 3ds Max empowers customers and partners to get more work done more quickly, reliably and collaboratively using cloud-based web services.
Using automation routines, you can build custom solutions using 3ds Max in the cloud.
No local resources are needed, so it could be a commercial website/configurator type webapp, or it could be a pipeline automation that run from your in-house tools.
The sky (or rather the cloud) is the limit.
We will demonstrate how you can easily automate common workflows in 3ds Max.
<br/><a href="https://autodesk.zoom.us/webinar/register/WN_7jTFtqz3Tte76LswrUACvw">Register</a></li>
</ul>
<h4><a name="3"></a> Stacking Two 24x24 Ribbon Items</h4>
<p>Jameson Nyp, BIM Manager and IS Director at <a href="https://teliospc.com">Telios Engineering</a> in Dallas, Texas, shares a nice solution for stacking two ribbon items in
his <a href="http://forums.autodesk.com/t5/revit-api-forum/bd-p/160">Revit API discussion forum</a> thread
on <a href="https://forums.autodesk.com/t5/revit-api-forum/24x24-stackeditems/m-p/9168470">24x24 StackedItems</a>:</p>
<p><strong>Qutestion:</strong> This may be an easy one, but so far I am struggling to find anything specific about it.</p>
<p>How do you make a <code>StackedItem</code> where the icons are 24x24 when there are only 2 in the stack?</p>
<p>It seems like it should be possible, as it is used multiple times in the modify tab:</p>
<p><center>
<img src="img/modify_tab_icon_sizes.png" alt="Modify tab icon sizes" width="246"> <!--246-->
</center></p>
<p>I have been able to set the <code>ShowText</code> property to false to get the 3 stacked icons, but when I use the same methodology with the 2 icon stack, it remains 16x16, regardless of the icon resolution.</p>
<p>I tried to obtain and change the button's height and width, minWidth and minHeight through the Autodesk.Window.RibbonItem object to no avail.</p>
<p>Has anyone had any success in creating these icons?</p>
<p><strong>Answer:</strong> I found a solution.</p>
<p>In order to display the button at the 24x24 size, the Autodesk.Windows.RibbonItem.Size needs to be manually set to Autodesk.Windows.RibbonItemSize.Large enum and a 24x24 icon needs to be set to the button's <code>LargeImage</code> property.</p>
<p>Here is a code samnple:</p>
<pre class="code">
using Autodesk.Revit.UI;
using Autodesk.Windows;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Windows.Media.Imaging;
using YourCustomUtilityLibrary;

namespace ReallyCoolAddin
{
  public class StackedButton
  {
    public IList<Autodesk.Revit.RibbonItem> Create(RibbonPanel ribbonPanel)
    {
      // Get Assembly
      Assembly assembly = Assembly.GetExecutingAssembly();
      string assemblyLocation = assembly.Location;

      // Get DLL Location
      string executableLocation = Path.GetDirectoryName(assemblyLocation);
      string dllLocationTest = Path.Combine(executableLocation, "TestDLLName.dll");

      // Set Image
      BitmapSource pb1Image = UTILImage.GetEmbeddedImage(assembly, "Resources.16x16_Button1.ico");
      BitmapSource pb2Image = UTILImage.GetEmbeddedImage(assembly, "Resources.16x16_Button2.ico");
      BitmapSource pb1LargeImage = UTILImage.GetEmbeddedImage(assembly, "Resources.24x24_Button1.ico");
      BitmapSource pb2LargeImage = UTILImage.GetEmbeddedImage(assembly, "Resources.24x24_Button2.ico");

      // Set Button Name
      string buttonName1 = "ButtonTest1";
      string buttonName2 = "ButtonTest2";

      // Create push buttons
      PushButtonData buttondata1 = new PushButtonData(buttonName1, buttonTextTest, dllLocationTest, "Command1");
      buttondata1.Image = pb1Image;
      buttondata1.LargeImage = pb1LargeImage;

      PushButtonData buttondata2 = new PushButtonData(buttonName2, buttonTextTest, dllLocationTest, "Command2");
      buttondata2.Image = pb2Image;
      buttondata2.LargeImage = pb2LargeImage;

      // Create StackedItem
      IList<Autodesk.Revit.RibbonItem> ribbonItem = ribbonPanel.AddStackedItems(buttondata1, buttondata2);

      // Find Autodes.Windows.RibbonItems
      UTILRibbonItem utilRibbon = new UTILRibbonItem();
      var btnTest1 = utilRibbon.getButton("Tab", "Panel", buttonName1);
      var btnTest2 = utilRibbon.getButton("Tab", "Panel", buttonName2);

      // Set Size and Text Visibility
      btnTest1.Size = RibbonItemSize.Large;
      btnTest1.ShowText = false;
      btnTest2.Size = RibbonItemSize.Large;
      btnTest2.ShowText = false;

      // Return StackedItem
      return ribbonItem;
    }
  }
}
</pre>

<p>Many thanks to Jameson for raising and solving this issue.</p>
<h4><a name="4"></a> Reinitialising the Filtered Element Collector</h4>
<p>Yet another important hint
from Frank <a href="https://forums.autodesk.com/t5/user/viewprofilepage/user-id/2083518">@Fair59</a> Aarssen
on reinitialising the filtered element collector
for <a href="https://forums.autodesk.com/t5/revit-api-forum/collection-of-elements-created-using-elementworksetfilter-giving/m-p/9164018">collection of elements created using <code>ElementWorksetFilter</code> giving incorrect count</a>:</p>
<p>You need to reinitialise a filtered element collector before reusing it.
All the filters that you add to it are accumulated.
If they are mutually exclusive, you will get zero results.</p>
<p><strong>Question:</strong> I'm trying to retrieve empty worksets, but the count method of the collection of elements in a particular workset is not giving correct results.
Here is my code:</p>
<pre class="code">
  FilteredElementCollector fec = new FilteredElementCollector(doc);
  FilteredWorksetCollector fwc = new FilteredWorksetCollector(doc);
  fwc.OfKind(WorksetKind.UserWorkset);

  try
  { 
    string msg = "";
    int count = 0;
    Transaction t = new Transaction(doc);
    t.Start("Check Empty Worksets");
    foreach (Workset w in fwc)
    {
      ElementWorksetFilter ewf = new ElementWorksetFilter(w.Id, false);
      ICollection<ElementId> elemIds = fec.WherePasses(ewf).ToElementIds();
      int foundElems = elemIds.Count;
      TaskDialog.Show("Elements:", w.Name + ": " + foundElems.ToString());
      if(foundElems == 0)
      {
        count++;
        msg += count.ToString() + ". " + w.Name + "\n";
      }
    }
    if (count == 0) msg = "None";
    TaskDialog.Show("Empty Worksets: ", msg);

    t.Commit();
    t.Dispose();
  }
  catch(Exception e)
  {
    TaskDialog.Show("Error", e.ToString());
  }
</pre>

<p><strong>Answer:</strong> A <code>FilteredElementCollector</code> isn't a static variable, but a dynamic collection.</p>
<p>Every time you apply a filter, the elements that don't pass the filter are removed from the collection.</p>
<p>So, after the first pass of the <code>foreach</code> loop, the collector only contains the elements belonging to the first workset.</p>
<p>All those elements aren't part of the second workset (2nd pass) and therefore the collector is empty after the second pass. </p>
<p>Solution: reinitialize the collector in every pass:</p>
<pre class="code">
foreach (Workset w in fwc)
{
    ElementWorksetFilter ewf = new ElementWorksetFilter(w.Id, false);
    ICollection<ElementId> elemIds = new FilteredElementCollector(doc).WherePasses(ewf).ToElementIds();
    int foundElems = elemIds.Count;
    count++;
    msg += foundElems.ToString() + ". " + w.Name + "\n";
}
</pre>

<p>Many thanks to Fair59 for yet another valuable solution.</p>
<p>By the way, you might also want
to <a href="https://thebuildingcoder.typepad.com/blog/2012/04/using-using-automagically-disposes-and-rolls-back.html">simplify your transaction handling by wrapping it in a <code>using</code> statement</a>.
However, I also wonder whether you need any transaction at all for this read-only operation.</p>
<p>This misunderstanding caused a similar initial problem in another recent case involving 
a <a href="https://forums.autodesk.com/t5/revit-api-forum/material-assets-collector-appearance-structural-physical-amp/m-p/7256944">material assets collector for appearance, structural (physical) and thermal</a>.</p>
<h4><a name="5"></a> CreateReferenceInLink Simplifies Selecting a Face in a Linked File</h4>
<p>Back in 2012, we discussed a pretty convoluted solution 
for [Selecting a Face in a Linked File](https://thebuildingcoder.typepad.com/blog/2012/05/selecting-a-face-in-a-linked-file.html#comment-4704876157}.</p>
<p>Joshua Lumley added a <a href="https://thebuildingcoder.typepad.com/blog/2012/05/selecting-a-face-in-a-linked-file.html#comment-4704877758">comment</a> to
that old po0st, pointing out that:</p>
<blockquote>
<p>The <code>CreateReferenceInLink</code> was added after that discussion, in Revit 2014.</p>
<p>To select any face anywhere, all you need is this:</p>
</blockquote>
<pre class="code">
public static Face SelectFace(UIApplication uiapp)
{
Document doc = uiapp.ActiveUIDocument.Document;

IEnumerable<document> doc2 = GetLinkedDocuments(doc);

Autodesk.Revit.UI.Selection.Selection sel = uiapp.ActiveUIDocument.Selection;

Reference pickedRef = sel.PickObject(Autodesk.Revit.UI.Selection.ObjectType.PointOnElement, "Please select a Face");

Element elem = doc.GetElement(pickedRef.ElementId);

Type et = elem.GetType();

if (typeof(RevitLinkType) == et || typeof(RevitLinkInstance) == et || typeof(Instance) == et)
{
foreach (Document d in doc2)
{
if (elem.Name.Contains(d. Title))
{
Reference pickedRefInLink = pickedRef.CreateReferenceInLink();

Element myElement = d.GetElement(pickedRefInLink.ElementId);

Face myGeometryObject = myElement.GetGeometryObjectFromReference(pickedRefInLink) as Face;
return myGeometryObject;
}
}
} else
{
Element myElement = doc.GetElement(pickedRef.ElementId);

Face myGeometryObject = myElement.GetGeometryObjectFromReference(pickedRef) as Face;

return myGeometryObject;
}
return null;
}
</pre>