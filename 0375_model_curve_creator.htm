<head>
<link rel="stylesheet" type="text/css" href="bc.css">
</head>

<!-- 1259898 [How to retrieve a curtain wall's geometry] -->

<h3>Model Curve Creator</h3>

<p>I showed a screen snapshot in the discussion of the 

<a href="http://thebuildingcoder.typepad.com/blog/2010/05/curtain-wall-geometry.html.html">
curtain wall geometry</a> that

I generated by querying the curtain wall for its non-visible curves and generating model curves from those to visualise them, offset from the curtain wall itself by the curtain wall length to make them easier to distinguish.

<p>I would now like to discuss the code and some new methods that I added to The Building Coder 

<a href="http://thebuildingcoder.typepad.com/blog/2008/11/model-line-creation.html">
model curve Creator class</a> in

order to achieve that.

<p>I started off by implementing a new Building Coder sample command CmdCurtainWallGeom to perform the following steps:

<ul>
<li>Select the curtain wall.
<li>Extract its location line.
<li>Determine the wall length vector v for offsetting the model line visualisation results.
<li>Query the wall for its non-visible geometry.
<li>For each curve returned, generate a model line offset by the vector v.
</ul>

<p>The offset curves are easy to generate at a high level by creating a translation Transform instance and using the Curve method get_Transformed. 

<p>In previous uses of the Creator class to display 

<a href="http://thebuildingcoder.typepad.com/blog/2008/11/slab-side-faces.html">
slab side faces</a>, 

<a href="http://thebuildingcoder.typepad.com/blog/2008/11/wall-compound-layers.html">
wall compound layers</a> and the

<a href="http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html">
wall elevation profile</a>,

we expended much more effort to much less effect by breaking down the curves into individual points, translating each point individually, and creating model lines between the points, i.e. losing support for all other non-linear curve types.

<p>Noticing this inefficiency and information loss, I re-implemented the model curve creation to handle all curve types, not just straight lines. 
The implementation was simultaneously enhanced, shortened and simplified.

<p>One important new component for this is the GetCurveNormal method which I recently presented in the discussion 

<a href="http://thebuildingcoder.typepad.com/blog/2010/05/detail-curve-must-be-in-plane.html">
the detail curve plane</a>.

It determines a normal vector to use to create a sketch plane for an arbitrary given curve.
If the curve is a straight line, the resulting plane can be any of many planes containing the curve.
If not, we use the curve tessellation points to determine a plane containing the curve, assuming it is planar.

<p>With that method in place, it is extremely simple to create a sketch plane containing any given planar curve:

<pre class="code">
<span class="teal">SketchPlane</span> NewSketchPlaneContainCurve(
&nbsp; <span class="teal">Curve</span> curve )
{
&nbsp; <span class="teal">XYZ</span> p = curve.get_EndPoint( 0 );
&nbsp; <span class="teal">XYZ</span> normal = GetCurveNormal( curve );
&nbsp; <span class="teal">Plane</span> plane = _app.NewPlane( normal, p );
&nbsp;
&nbsp; <span class="blue">return</span> _doc.NewSketchPlane( plane );
}
</pre>

<p>With that method in place, it is simpler still, in fact completely trivial, to create a model curve from a given geometrical curve:

<pre class="code">
<span class="blue">public</span> <span class="blue">void</span> CreateModelCurve( <span class="teal">Curve</span> curve )
{
&nbsp; _doc.NewModelCurve( curve,
&nbsp; &nbsp; NewSketchPlaneContainCurve( curve ) );
}
</pre>

<p>With these two new methods on the Creator class in place, the code to implement the steps described above becomes quite short and sweet:

<pre class="code">
[<span class="teal">Transaction</span>( <span class="teal">TransactionMode</span>.Automatic )]
[<span class="teal">Regeneration</span>( <span class="teal">RegenerationOption</span>.Manual )]
<span class="blue">class</span> <span class="teal">CmdCurtainWallGeom</span> : <span class="teal">IExternalCommand</span>
{
&nbsp; <span class="blue">public</span> <span class="teal">Result</span> Execute(
&nbsp; &nbsp; <span class="teal">ExternalCommandData</span> commandData,
&nbsp; &nbsp; <span class="blue">ref</span> <span class="blue">string</span> message,
&nbsp; &nbsp; <span class="teal">ElementSet</span> elements )
&nbsp; {
&nbsp; &nbsp; <span class="teal">UIApplication</span> uiapp = commandData.Application;
&nbsp; &nbsp; <span class="teal">UIDocument</span> uidoc = uiapp.ActiveUIDocument;
&nbsp; &nbsp; <span class="teal">Application</span> app = uiapp.Application;
&nbsp; &nbsp; <span class="teal">Document</span> doc = uidoc.Document;
&nbsp;
&nbsp; &nbsp; <span class="teal">Wall</span> wall = <span class="teal">Util</span>.SelectSingleElementOfType(
&nbsp; &nbsp; &nbsp; uidoc, <span class="blue">typeof</span>( <span class="teal">Wall</span> ), <span class="maroon">&quot;a curtain wall&quot;</span> ) 
&nbsp; &nbsp; &nbsp; <span class="blue">as</span> <span class="teal">Wall</span>;
&nbsp;
&nbsp; &nbsp; <span class="blue">if</span>( <span class="blue">null</span> == wall )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; message = <span class="maroon">&quot;Please select a single &quot;</span>
&nbsp; &nbsp; &nbsp; &nbsp; + <span class="maroon">&quot;curtain wall element.&quot;</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="blue">else</span>
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; <span class="teal">LocationCurve</span> locationcurve
&nbsp; &nbsp; &nbsp; &nbsp; = wall.Location <span class="blue">as</span> <span class="teal">LocationCurve</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Curve</span> curve = locationcurve.Curve;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="green">// move whole geometry over by length of wall:</span>
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">XYZ</span> p = curve.get_EndPoint( 0 );
&nbsp; &nbsp; &nbsp; <span class="teal">XYZ</span> q = curve.get_EndPoint( 1 );
&nbsp; &nbsp; &nbsp; <span class="teal">XYZ</span> v = q - p;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Transform</span> tv = <span class="teal">Transform</span>.get_Translation( v );
&nbsp;
&nbsp; &nbsp; &nbsp; curve = curve.get_Transformed( tv );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Creator</span> creator = <span class="blue">new</span> <span class="teal">Creator</span>( doc );
&nbsp; &nbsp; &nbsp; creator.CreateModelCurve( curve );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">Options</span> opt = app.Create.NewGeometryOptions();
&nbsp; &nbsp; &nbsp; opt.IncludeNonVisibleObjects = <span class="blue">true</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="teal">GeometryElement</span> e = wall.get_Geometry( opt );
&nbsp;
&nbsp; &nbsp; &nbsp; <span class="blue">foreach</span>( <span class="teal">GeometryObject</span> obj <span class="blue">in</span> e.Objects )
&nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; curve = obj <span class="blue">as</span> <span class="teal">Curve</span>;
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="blue">if</span>( <span class="blue">null</span> != curve )
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curve = curve.get_Transformed( tv );
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; creator.CreateModelCurve( curve );
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="blue">return</span> <span class="teal">Result</span>.Succeeded;
&nbsp; }
}
</pre>

<p>I already showed the result of running this command and picking a curved curtain wall:</p>

<center>
<img src="img/curtain_wall_offset_model_lines.png" alt="Model lines generated from curtain wall perimeter curves offset by wall length"/>
</center>

<p>Here is

<a href="zip/bc_11_69.zip">
version 2011.0.69.0</a>

of The Building Coder sample source code and Visual Studio solution including the new command.
